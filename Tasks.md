# Practice Document

## Types Basics

### Завдання 02.01 Базові типи

1. Реалізуйте функцію **getAllBooks()**, яка повертає колекцію книжок. Об’явіть цю колекцію всередині функції.
    + ```javascript
        [
          { id: 1, title: 'Refactoring JavaScript', author: 'Evan Burchard', available: true},
          { id: 2, title: 'JavaScript Testing', author: 'Liang Yuxian Eugene', available: false },
          { id: 3, title: 'CSS Secrets', author: 'Lea Verou', available: true },
          { id: 4, title: 'Mastering JavaScript OOP', author: 'Andrea Chiarelli', available: true }
        ]
      ```
2. Реалізуйте функцію **logFirstAvailable()**, яка приймає масив книг як параметр і виводить у консоль:\
   _кількість книг у масиві та назву першої доступної книги_
    + Запустіть функцію ``logFirstAvailable()``
3. Об’явіть **enum Category** для зберігання наступних категорій книг: JavaScript, CSS, HTML, TypeScript, Angular.
    + Додайте категорію до об'єктів у функції getAllBooks().
4. Реалізуйте функцію **getBookTitlesByCategory()**, яка на вхід повинна отримувати категорію та повертати масив найменувань книг, що належать зазначеній категорії.
5. Реалізуйте функцію **logBookTitles()**, яка повинна приймати масив рядків та виводити його в консоль.
    + Викличте функції ``getBookTitlesByCategory()`` та ``logBookTitles()``.
6. Реалізуйте функцію **getBookAuthorByIndex()**, яка повинна приймати index книжки у масиві та повертати пару: назву книжки + автор.\
    + Використовуйте ``tuple`` для типу, що повертається. Викличте цю функцію.
    + Внесіть зміни до типу, що повертається функцією **getBookAuthorByIndex()** – додайте мітки: title, author для типу tuple.
7. Реалізуйте функцію **calcTotalPages()**, яка повинна підраховувати кількість сторінок книг у трьох бібліотеках міста, використовуючи такі дані:
    + ```javascript
        [
          { lib: 'libName1', books: 1_000_000_000, avgPagesPerBook: 250 }, 
          { lib: 'libName2', books: 5_000_000_000, avgPagesPerBook: 300 },
          { lib: 'libName3', books: 3_000_000_000, avgPagesPerBook: 280 }
        ];     
      ```
    + Для підрахунків використовуйте тип bigint.
   
### Завдання 02.02 Приведення до константи

1. Додайте **const assertions** (<const>) для масиву книг та масиву, який містить інформацію про сторінки книг у бібліотеках міста.
2. Додайте модифікатор **readonly** для параметра функції **logFirstAvailable()**

## Functions

### Завдання 03.01. Функціональний тип

1. Створіть функцію **createCustomerID()**, яка приймає ім'я клієнта (name:string) та його ідентифікатор (id:number) та повертає конкатенацію цих значень у вигляді рядка.
2. Об’явіть змінну **myID** рядкового типу та викличте функцію зі значеннями *Ann, 10*.
     + Отримане значення виведіть у консоль.
3. Об’явіть змінну **idGenerator** і вкажіть тип функції **createCustomerID()**.
     + Надайте цій змінній функціональний вираз, використовуючи стрілочну функцію.
     + Тіло подібне до функції createCustomerID().
4. Надайте змінній **idGenerator** функцію **createCustomerID()** та викличте її.
     + Отримане значення виведіть у консоль.

### Завдання 03.02. Необов’язкові, значення за замовчуванням та рест параметри

1. Створіть функцію **createCustomer()**, яка приймає три параметри:
    - •	name: string – обов'язковий
    - •	age: number – необов'язковий
    - •	city: string – необов'язковий
    + Функція повинна виводити ім'я клієнта в консоль, а також, якщо заданий вік, вона повинна додатково виводити вік у консоль.
    + Якщо задане місто, то додатково має виводити місто у консоль.
    + Викличте цю функцію з одним, двома та трьома аргументами.
2. Внесіть зміни до функції **getBookTitlesByCategory()**
     - додайте для параметра значення за замовчуванням **Category.JavaScript**.
     - Викличте цю функцію без аргумента.
3. Внесіть зміни до функції **logFirstAvailable()**
     - додайте для параметра значення за замовчуванням – виклик функції **getAllBooks()**.
     - Викличте цю функцію без аргументів.
4. Створіть функцію **getBookByID()**, яка приймає id книжки та повертає книжку.
     + Використовуйте функцію **getAllBooks()**, метод масиву **find()** та стрілочну функцію.
     + Викличте функцію та передайте їй 1.
5. Створіть функцію **сheckoutBooks()**, яка приймає два параметри:
     - •	customer: string
     - •	bookIDs: number[] – змінне значення ідентифікаторів книжок (рест параметр)
     + Функція повинна перевірити доступність кожної книжки, заданої ідентифікатором, та повернути масив найменувань (title) книжок, які є доступними. (available = true).
     + Використовуйте функцію getBookById(). Також функція повинна виводити в консоль ім'я заданого клієнта.
6. Об’явіть змінну **myBooks** та збережіть у ній результат виклику функції **сheckoutBooks('Ann', 1, 2, 4)**.
     + Виведіть результат у консоль.

### Завдання 03.03. Перевантаження функцій

1. Додайте в першому рядку **app.ts** опцію для ESLint ``/* eslint-disable no-redeclare */``.
     - Ця опція необхідна для оголошення кількох сигнатур функцій з однаковими іменами.
2. Створіть функцію **getTitles()**, яка повинна приймати 1 або 2 аргументи:
     - •	якщо функція приймає 1 аргумент, то він повинен бути або string (author), або boolean (available)
     - •	якщо функція приймає 2 аргументи, то вони повинні бути number (id) та boolean (available).
     + Функція повинна повертати масив книг за автором, чи за доступністю, чи за id та доступністю.
     + Для реалізації функції створіть три сигнатури з різними типами параметрів та реалізацію з рест параметром типу ``any[]`` або ``unknown[]`` або ``[string | boolean] | [number, boolean]``.
     + Функція повинна аналізувати кількість і типи параметрів за допомогою оператора ``typeof``
     + і формувати результуючий масив з масиву, отриманого за допомогою функції **getAllBooks()**, аналізуючи властивості: ``book.author, book.available, book.id``.
3. Оголосіть змінну **checkedOutBooks** та викличте функцію **getTitles(false)**.
     + Виведіть результат у консоль.

### Завдання 03.04. Функції-ствердження

1. Створіть функцію-ствердження **assertStringValue()**, яка повинна приймати один параметр типу any.
     - Функція повинна перевіряти, чи є тип переданого аргументу рядком. Якщо ні, то генерувати виняток ``"value should have been a string"``.
2. Створіть функцію **bookTitleTransform()**, яка повинна приймати один параметр ``title`` – назву книжки (тип параметру any).
     - За допомогою функції **assertStringValue()** повинна перевіряти, чи назва книжки дійсно є рядком,
     - і якщо так, то повинна повертати перевертень цього рядка, використовуючи спред оператор і методи масиву ``reverse()`` і ``join()``.
3. Викличте функцію **bookTitleTransform()** двічі і передайте їй рядкове та числове значення.

## Interfaces

### Завдання 04.01. Об’явлення інтерфейсу 

1. Об’явіть **інтерфейс Book**, який включає такі поля:
     - •	id - число
     - •	title - рядок
     - •	author - рядок
     - •	available - логічний
     - •	category – категорія
2. Внесіть зміни в функцію **getAllBooks()**, вкажіть тип для змінної ``books`` і тип для значення, що повертається, використовуючи інтерфейс Book. 
     - Додайте модифікатор ``readonly``. 
     - Видаліть тимчасово id у книжки. Ви побачите, що з'явиться помилка.
3. Внесіть зміни в функцію **getBookByID()**, вкажіть тип ``Book['id']`` для параметра ``id``, а також вкажіть тип для значення, що повертається, використовуючи інтерфейс Book. 
     - Можливо, доведеться додати об'єднання з типом ``undefined``, оскільки метод ``find``, якщо не знайде елемент, поверне undefined.
4. Створіть функцію **printBook()**, яка повинна приймати один параметр - книгу та виводити у консоль фразу ``book.title + by + book.author``. 
     - Використайте інтерфейс Book для типу параметра.
5. Об’явіть змінну **myBook** і присвойте їй наступний об'єкт
    + ```javascript
        {
            id: 5,
            title: 'Colors, Backgrounds, and Gradients',
            author: 'Eric A. Meyer',
            available: true,
            category: Category.CSS,
            year: 2015,
            copies: 3
        }
      ```
6. Викличте функцію **printBook()** та передайте їй ``myBook``. 
     - Жодних помилок при цьому не повинно з'являтися.
7. Додайте до інтерфейсу **Book** властивість ``pages: number``. 
     - Ви отримаєте помилку у функції **getAllBooks()**. 
     - Щоб помилка не виникала, зробіть властивість необов'язковою.
8. Вкажіть явно для змінної myBook тип Book. Ви знову отримаєте помилку. 
     - Видаліть властивості year, copies. 
     - Додайте властивість pages: 200.
9. Додайте в інтерфейс **Book** необов'язкову властивість ``markDamaged``, яка є методом.
     - Метод повинен приймати рядковий параметр ``reason`` і нічого не повертати.
     - Додайте цей метод до **myBook**. Метод повинен виводити рядок `Damaged: ${reason}`.
     - Викличте цей метод та передайте рядок ``'missing back cover'``.

### Завдання 04.02. Об’явлення інтерфейсу для функціонального типу

1. Об’явіть **інтерфейс DamageLogger**, який описуватиме тип функції, яка повинна приймати один рядковий параметр і нічого не повертати.
2. Внесіть зміни до **інтерфейсу Book**: використайте інтерфейс DamageLogger для поля markDamaged.
3. Об’явіть **змінну logDamage**, використовуючи інтерфейс **DamageLogger**. 
     - Створіть функцію, яка задовольняє цьому інтерфейсу, і присвойте її  змінній logDamage. 
     - Викличте функцію.

### Завдання 04.03. Розширення інтерфейсів

1. Об’явіть **інтерфейс Person**, який містить дві рядкові властивості – ``name`` і ``email``.
2. Об’явіть **інтерфейс Author** на основі інтерфейсу **Person**, який розширює вказаний інтерфейс числовою властивістю ``numBooksPublished``.
3. Об’явіть **інтерфейс Librarian** на основі інтерфейсу **Person**, який розширює цей інтерфейс двома властивостями:
     - •	Рядкова властивість department
     - •	Функція assistCustomer, яка повинна приймати два рядкові параметри custName і bookTitle і нічого не повертати.
4. Об’явіть **змінну favoriteAuthor**, використовуючи інтерфейс **Author**, задайте значення у вигляді літерала об'єкта.
5. Об’явіть **змінну favoriteLibrarian**, використовуючи інтерфейс **Librarian**, задайте значення у вигляді літерала об'єкта.

### Завдання 04.04. Необов’язковий ланцюжок

1. Об’явіть **змінну offer** наступного виду:
    + ```javascript
        const offer: any = {
           book: {
              title: 'Essential TypeScript',
           },
        };
      ```
2. Виведіть у консоль значення таких виразів, використовуючи оператор **(?.)**
     - •	offer.magazine
     - •	offer.magazine.getTitle()
     - •	offer.book.getTitle()
     - •	offer.book.authors[0]
     - •	offer.book.authors[0].name

### Завдання 04.05. keyof оператор

1. Об’явіть **тип BookProperties**, який має бути об’єднанням рядкових літеральних типів властивостей інтерфейсу **Book**, використовуючи ``keyof`` оператор.
2. Створіть **функцію getProperty()**, яка повинна приймати два параметри:
     - •	книжку
     - •	назву властивості з інтерфейсу Book
     - і повертати значення цієї властивості з переданого об'єкта, якщо це не функція, а для функції повертати її ім'я. 
     - Використайте тип ``any`` для значення, що повертається.
3. Викличте функцію ``getProperty()`` тричі зі значенням другого аргумента: title, markDamaged, isbn.

## Classes

### Завдання 05.01. Створення та використання класів

1. Створіть **клас ReferenceItem**, який містить:
    - •	Рядкову властивість title
    - •	Числову властивість year
2. Додайте **конструктор**, який повинен приймати два параметри:
    - •	рядковий параметр newTitle, 
    - •	числовий параметр newYear, 
    - виводити у консоль рядок 'Creating a new ReferenceItem...'
    - та ініціалізувати властивості title та year.
3. Додайте **метод printItem()**, який повинен нічого не приймати і нічого не повертати. 
    - Цей метод повинен виводити рядок "title was published in year" в консоль.
4. Об’явіть **змінну ref** та проініціалізуйте її об'єктом ReferenceItem. 
    - Передайте значення для параметрів конструктора.
    - Викличте метод `printItem()`.
5. Закоментуйте конструктор, властивості title та year та реалізуйте створення властивостей через параметри конструктора title - public, year - private.
6. Створіть приватну **(“soft private”)** рядкову властивість **_publisher**.
    - •	Додайте гетер `publisher`, який повинен повертати значення властивості `_publisher` у верхньому регістрі.
    - •	Додайте сеттер `publisher`, який повинен приймати рядковий параметр `newPublisher` і встановлює значення властивості `_publisher` в значення цього параметра.
    - •	Проініціалізуйте властивість `ref.publisher` будь-яким рядковим значенням і виведіть її значення в консоль. Результат має бути у верхньому регістрі.
7. Створіть приватну **(“hard private”)** числову властивість **id**.
    - •	Внесіть зміни до конструктора для ініціалізації цієї властивості.
    - •	Додайте метод `getID()`, який повинен повертати значення властивості id.
    - •	Виведіть об'єкт у консоль.
    - •	Викличте метод `getID()`.
8. Створіть **статичну** рядкову властивість **department**
    - проініціалізуйте її будь-яким значенням за замовчуванням.
    - Внесіть зміни до методу `printItem()` – метод повинен додатково виводити значення цієї статичної властивості у консоль.


### Завдання 05.02. Розширення класів

1. Створіть **клас Encyclopedia** як похідний клас **від ReferenceItem**. 
    - Додайте одну додаткову числову публічну властивість `edition`. 
    - Використайте параметри конструктора.
2. Об’явіть **змінну refBook** та створіть об'єкт **Encyclopedia**. 
    - Викличте метод `printItem()`;
3. Перевизначте **метод printItem()**.
    - Додайте ключове слово `override`.
    - Метод повинен виконувати те, що виконував раніше
    - та додатково повинен виводити рядок у консоль «Edition: edition (year)».
    - Ви отримаєте помилку, що властивість year недоступна.
    - Щоб властивість стала доступна, змініть модифікатор доступу в класі ReferenceItem з private на protected.

### Завдання 05.03. Абстрактні класи

1. Внесіть зміни до **класу ReferenceItem** 
    - зробіть його абстрактним.
2. Створіть **абстрактний метод printCitation()**, 
    - який повинен не приймати параметрів і не повертати значення. 
    - Цей метод має бути без реалізації. 
    - Після цього Ви отримаєте помилку в класі Encyclopedia, яка повідомлятиме, що не реалізовано абстрактний метод.
3. Створіть **метод printCitation()** у класі Encyclopedia. 
    - Метод повинен виводити в консоль рядок "title - year".
4. Об’явіть **змінну refBook** та проініціалізуйте її об'єктом Encyclopedia. 
    - Викличте метод `printCitation()`.

### Завдання 05.04. Реалізація інтерфейсів класами

1. Створіть **клас UniversityLibrarian**, який повинен реалізовувати інтерфейс Librarian та реалізуйте всі необхідні властивості. 
    - Метод `assistCustomer()` повинен виводити в консоль рядок `${this.name} is assisting ${custName} with the book ${bookTitle}`.
2. Об’явіть **змінну favoriteLibrarian** за допомогою інтерфейсу Librarian і проініціалізуйте її за допомогою об'єкта, створеного класом UniversityLibrarian. 
    - Жодних помилок при цьому не повинно виникати. 
    - Проініціалізуйте властивість name та викличте метод assistCustomer().

### Завдання 05.05. Перетин та об’єднання типів

1. Створіть **тип PersonBook**. Використовуйте для цього інтерфейси Person, Book та перетин типів.
2. Об’явіть **змінну з типом PersonBook**, проініціалізуйте її літералом, виведіть її в консоль.
3. Створіть **тип BookOrUndefined**.
     - Використовуйте для цього об'єднання інтерфейсу Book та undefined.
4. Замініть тип значення, що повертається у функції getBookByID() на BookOrUndefined.
5. Створіть **функцію setDefaultConfig()**, яка приймає об'єкт options. 
    - Тип для об'єкта TOptions об’явіть за допомогою інтерфейса з необов'язковими числовими властивостями duration і speed. 
    - Функція повинна встановлювати значення властивостей за замовчуванням 
    - якщо вони не мають ніякого значення, використовуючи логічний оператор налового присвоєння та повертати об'єкт.


### Modules and Namespaces

#### Завдання 06.01. Використання простору імен
#### Завдання 06.02. Експорт та імпорт
#### Завдання 06.03. Експорт за замовчуванням
#### Завдання 06.04. Реекспорт
#### Завдання 06.05. Вираз динамічного імпорту
#### Завдання 06.06. Імпорт та експорт типів


## Generics

### Завдання 07.01. Загальні функції

1. Створіть у файлі **functions.ts** дженерик (загальну) функцію **purge()**, 
    - яка приймає один параметр – дженерик масив `inventory` та 
    - повертає дженерик масив того ж типу, що містить елементи початкового масиву без двох перших елементів. 
    - Експортуйте цю функцію.
2. Імпортуйте функцію **purge()** у **app.ts.**
3. Додайте категорію **Software** у файл **enums.ts**.
4. Об’явіть **змінну inventory**, що містить наступний масив книг
     ```javascript
       [
         { id: 10, title: 'The C Programming Language', author: 'K & R', available: true, category: Category.Software },
         { id: 11, title: 'Code Complete', author: 'Steve McConnell', available: true, category: Category.Software },
         { id: 12, title: '8-Bit Graphics with Cobol', author: 'A. B.', available: true, category: Category.Software },
         { id: 13, title: 'Cool autoexec.bat Scripts!', author: 'C. D.', available: true, category: Category.Software }
       ]; 
     ```
5. Викличте функцію **purge()** та передайте їй ці дані. 
    - Виведіть результат у консоль.
6. Викличте функцію **purge()** з числовим масивом 
    - і знову виведіть результат у консоль.
7. Об’явіть змінну **purgeNumbers** та присвойте їй функцію purge зі значенням параметру типу number. 
    - Викличте функцію `purgeNumbers()` та передайте їй числовий масив та масив рядків.
8. Додайте **in/out/in out** до параметру типу у функції **purge()**.

### Завдання 07.02. Загальні інтерфейси і класи

1. Створіть **інтерфейс Magazine**, 
    - який містить дві рядкові властивості, `title, publisher`
    - та додайте його у **файл interfaces.ts**. 
    - Експортуйте цей інтерфейс.
2. Створіть **файл classes/shelf.ts** і, використовуючи експорт за замовчуванням, реалізуйте **дженерик клас Shelf**:
    - •	додайте приватну властивість items, яка є масивом елементів типу Т.
    - •	додайте метод add(), який приймає один параметр item типу T і додає його в масив. Нічого не повертає.
    - •	додайте метод getFirst(), який нічого не приймає, і повертає перший елемент із items.
3. Додайте реекспорт у файл classes/index.ts
4. Імпортуйте клас Shelf і інтерфейс Magazine в app.ts.
5. Закоментуйте код, який відноситься до функції purge(), крім змінної inventory.
6. Створіть **екземпляр класу Shelf - bookShelf** і збережіть усі книжки з inventory в bookShelf.
    - Отримайте першу книжку і виведіть її назву в консоль.
7. Об'явіть змінну magazines, яка містить наступні дані:
    - ```javascript
        [
            { title: 'Programming Language Monthly', publisher: 'Code Mags' },
            { title: 'Literary Fiction Quarterly', publisher: 'College Press' },
            { title: 'Five Points', publisher: 'GSU' }
        ];
      ```
8. Створіть **екземпляр класу  Shelf - magazineShelf** і збережіть усі журнали в magazineShelf. 
    - Отримайте перший журнал і виведіть його в консоль.

### Завдання 07.03. Загальні обмеження

1. Внесіть зміни в **клас Shelf**:
    - •	додайте метод find(), який приймає рядковий параметр title і повертає перший знайдений елемент на полиці типу Т.
    - •	додайте метод printTitles(), який виводить у консоль назву того, що знаходиться на полиці.
    - Після додавання цих методів ви отримаєте помилку - властивість title не існує на типі T.
2. У файлі **interfaces.ts** створіть **інтерфейс ShelfItem**,
    - який повинен містити всі необхідні властивості, які повинен мати тип T, а саме title.
3. Додайте загальне обмеження для класу, розширив тип T від нього.
4. Викличте **метод printTitles()** для журналів.
5. Знайдіть **журнал 'Five Points'** і виведіть його в консоль.
6. Створіть **функцію getObjectProperty()**.
    - Додайте два параметра типу TObject, TKey.
    - Додайте обмеження для першого параметру, щоб значення були об’єктами.
    - Додайте обмеження для другого параметру, щоб значення були тільки ключами об’єкта типу TObject, використовуючи оператор keyof.
    - Для значення, яке повертається, вкажіть тип TObject[TKey] | string.
    - Тіло функції аналогічне тілу функції getProperty().
    - Викличте цю функцію.


### Завдання 07.04. Утиліти

1. Об'явіть **аліас типу BookRequiredFields** у файлі types.ts, використовуючи інтерфейс Book та утиліту Required.
2. Об'явіть **змінну bookRequiredFields** типу BookRequiredFields та присвойте їй відповідний об'єкт.
3. Об'явіть **аліас типу UpdatedBook**, використовуючи інтерфейс Book та утиліту Partial.
4. Об'явіть **змінну updatedBook** типу UpdatedBook і присвойте їй відповідний об'єкт.
5. Об'явіть **аліас типу AuthorWoEmail**, використовуючи інтерфейс Author та утиліту Omit.
6. Об'явіть **аліас СreateCustomerFunctionType** для функціонального типу функції createCustomer().
7. Об'явіть **змінну params**, використовуючи аліас типу СreateCustomerFunctionType і утиліту Parameters, 
    - викличте функцію createCustomer(), передавши змінну params.

### Завдання 07.05. Відображені типи, умовні типи

1. Об'явіть у файлі types.ts **аліас fn** для функціонального типу функції, яка приймає три параметри з типами string, number, boolean і повертає тип symbol.
2. Об'явіть **аліаси типів Param1<T>, Param2<T>, Param3<T>**, які повертають тип першого, другого та третього параметрів функції відповідно.
3. Об'явіть **аліаси P1, P2, P3** та отримайте типи першого, другого та третього параметрів типу fn.
> Автор: Olena_Hlukhovska@epam.com
4. Створіть **утиліти RequiredProps<T> та OptionalProps<T>** у файлі types.ts, які повертають union тип required та optional властивостей об'єкта. 
    - Використовуйте mapped type для перебору ключів T та conditional type для трансформації значень ключів типу T. 
    - Додайте загальне обмеження для T розширивши його від типу object у RequiredProps та OptionalProps.
5. Об'явіть **аліас типу BookRequiredProps та BookOptionalProps**, використовуючи інтерфейс Book та утиліти RequiredProps та OptionalProps. 
    - Спробуйте замість Book передати примітивний тип.
6. Створіть **утиліту RemoveProps <T extends object, TProps extends keyof T>**, яка видаляє властивості TProps з переданого типу T.
7. Об'явіть **аліас типу BookRequiredPropsType та BookOptionalPropsType**, використовуючи інтерфейс Book, аліаси типу BookRequiredProps та BookOptioalProps та утиліту RemoveProps Спробуйте замість Book передати Author.
> Домашне завдання Автор: Oleksandr_Cherevach@epam.com
8. Створіть **функцію update()**, яка приймає один параметр типу boolean.
    - Якщо значення аргументу true, функція повинна повертати значення типу string.
    - Якщо значення аргументу false, функція повинна повертати значення типу number.



## Decorators

### Завдання 08.01. Декоратор класу

1. Створіть **файл decorators.ts**. 
2. Створіть **декоратор класу @freeze()**, щоб запобігти додаванню нових властивостей об'єкту класу та прототипу об'єкта.
    - Функція-декоратор повинна приймати один рядковий параметр і нічого не повертати.
    - Перед виконанням функціонала функція має вивести у консоль повідомлення `"Freezing the constructor + параметр"`.
    - Використовуйте метод `Object.freeze()`.
3. Застосуйте цей декоратор до класу UniversityLibrarian.
4. Створіть **екземпляр класу UniversityLibrarian**. 
    - Перевірте повідомлення у консолі.

### Завдання 08.02. Декоратор класу

1. Створіть **декоратор класу @logger()**, який змінюватиме конструктор класу.
2. Об'явіть всередині декоратора **змінну newConstructor** та проініціалізуйте її функціональним виразом. 
    - Новий конструктор повинен:
    - •	виводити в консоль повідомлення "Creating new instance"
    - •	виводити переданий параметр (ім'я класу).
    - •	створювати нову властивість age зі значенням 30.
3. Проініціалізуйте прототип нового конструктора об'єктом, створеним на основі прототипу переданого класу, використовуючи Object.create() або Object.setPrototypeOf().
4. Додайте **новий метод** до прототипу нового конструктора **printLibrarian()**, 
    - який повинен виводити в консоль рядок `Librarian name: ${this.name}, Librarian age: ${this.age}`.
5. Поверніть з декоратора новий конструктор.
6. Добавте **параметр типу Return** з обмеженням new (...args: any[]) => any. 
    - Використайте цей параметр типу для типу originalClass, для типу значення, що повертається, 
    - а також приведіть значення, що повертається з декоратора до типу unknown а після того до типу Return.
7. Застосуйте цей декоратор до класу UniversityLibrarian. 
    - Перевірте результат роботи в консолі.
8. Об'явіть **змінну fLibrarian** та створіть екземпляр класу UniversityLibrarian. 
    - Вкажіть значення Anna для name. Викличте метод printLibrarian().

**Домашнє завдання:** Створіть декоратор класу, який збирає в множину всі створювані екземпляри класу.

### Завдання 08.03. Декоратор методу



### Завдання 08.04. Декоратор методу



### Завдання 08.05. Декоратор поля



### Завдання 08.06. Декоратор автоаксесора



### Завдання 08.07. Декоратор аксесорів




## Asynchronous Patterns

### Завдання 09.01. Функція зворотнього виклику



### Завдання 09.02. Проміси



### Завдання 09.03. Асинхронні функції













