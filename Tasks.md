# Practice Document

## Types Basics

### Завдання 02.01 Базові типи

1. Реалізуйте функцію **getAllBooks()**, яка повертає колекцію книжок. Об’явіть цю колекцію всередині функції.
    + ```javascript
        [
          { id: 1, title: 'Refactoring JavaScript', author: 'Evan Burchard', available: true},
          { id: 2, title: 'JavaScript Testing', author: 'Liang Yuxian Eugene', available: false },
          { id: 3, title: 'CSS Secrets', author: 'Lea Verou', available: true },
          { id: 4, title: 'Mastering JavaScript OOP', author: 'Andrea Chiarelli', available: true }
        ]
      ```
2. Реалізуйте функцію **logFirstAvailable()**, яка приймає масив книг як параметр і виводить у консоль:\
   _кількість книг у масиві та назву першої доступної книги_
    + Запустіть функцію ``logFirstAvailable()``
3. Об’явіть **enum Category** для зберігання наступних категорій книг: JavaScript, CSS, HTML, TypeScript, Angular.
    + Додайте категорію до об'єктів у функції getAllBooks().
4. Реалізуйте функцію **getBookTitlesByCategory()**, яка на вхід повинна отримувати категорію та повертати масив найменувань книг, що належать зазначеній категорії.
5. Реалізуйте функцію **logBookTitles()**, яка повинна приймати масив рядків та виводити його в консоль.
    + Викличте функції ``getBookTitlesByCategory()`` та ``logBookTitles()``.
6. Реалізуйте функцію **getBookAuthorByIndex()**, яка повинна приймати index книжки у масиві та повертати пару: назву книжки + автор.\
    + Використовуйте ``tuple`` для типу, що повертається. Викличте цю функцію.
    + Внесіть зміни до типу, що повертається функцією **getBookAuthorByIndex()** – додайте мітки: title, author для типу tuple.
7. Реалізуйте функцію **calcTotalPages()**, яка повинна підраховувати кількість сторінок книг у трьох бібліотеках міста, використовуючи такі дані:
    + ```javascript
        [
          { lib: 'libName1', books: 1_000_000_000, avgPagesPerBook: 250 }, 
          { lib: 'libName2', books: 5_000_000_000, avgPagesPerBook: 300 },
          { lib: 'libName3', books: 3_000_000_000, avgPagesPerBook: 280 }
        ];     
      ```
    + Для підрахунків використовуйте тип bigint.
   
### Завдання 02.02 Приведення до константи

1. Додайте **const assertions** (<const>) для масиву книг та масиву, який містить інформацію про сторінки книг у бібліотеках міста.
2. Додайте модифікатор **readonly** для параметра функції **logFirstAvailable()**

## Functions

### Завдання 03.01. Функціональний тип

1. Створіть функцію **createCustomerID()**, яка приймає ім'я клієнта (name:string) та його ідентифікатор (id:number) та повертає конкатенацію цих значень у вигляді рядка.
2. Об’явіть змінну **myID** рядкового типу та викличте функцію зі значеннями *Ann, 10*.
     + Отримане значення виведіть у консоль.
3. Об’явіть змінну **idGenerator** і вкажіть тип функції **createCustomerID()**.
     + Надайте цій змінній функціональний вираз, використовуючи стрілочну функцію.
     + Тіло подібне до функції createCustomerID().
4. Надайте змінній **idGenerator** функцію **createCustomerID()** та викличте її.
     + Отримане значення виведіть у консоль.

### Завдання 03.02. Необов’язкові, значення за замовчуванням та рест параметри

1. Створіть функцію **createCustomer()**, яка приймає три параметри:
    - •	name: string – обов'язковий
    - •	age: number – необов'язковий
    - •	city: string – необов'язковий
    + Функція повинна виводити ім'я клієнта в консоль, а також, якщо заданий вік, вона повинна додатково виводити вік у консоль.
    + Якщо задане місто, то додатково має виводити місто у консоль.
    + Викличте цю функцію з одним, двома та трьома аргументами.
2. Внесіть зміни до функції **getBookTitlesByCategory()**
     - додайте для параметра значення за замовчуванням **Category.JavaScript**.
     - Викличте цю функцію без аргумента.
3. Внесіть зміни до функції **logFirstAvailable()**
     - додайте для параметра значення за замовчуванням – виклик функції **getAllBooks()**.
     - Викличте цю функцію без аргументів.
4. Створіть функцію **getBookByID()**, яка приймає id книжки та повертає книжку.
     + Використовуйте функцію **getAllBooks()**, метод масиву **find()** та стрілочну функцію.
     + Викличте функцію та передайте їй 1.
5. Створіть функцію **сheckoutBooks()**, яка приймає два параметри:
     - •	customer: string
     - •	bookIDs: number[] – змінне значення ідентифікаторів книжок (рест параметр)
     + Функція повинна перевірити доступність кожної книжки, заданої ідентифікатором, та повернути масив найменувань (title) книжок, які є доступними. (available = true).
     + Використовуйте функцію getBookById(). Також функція повинна виводити в консоль ім'я заданого клієнта.
6. Об’явіть змінну **myBooks** та збережіть у ній результат виклику функції **сheckoutBooks('Ann', 1, 2, 4)**.
     + Виведіть результат у консоль.

### Завдання 03.03. Перевантаження функцій

1. Додайте в першому рядку **app.ts** опцію для ESLint ``/* eslint-disable no-redeclare */``.
     - Ця опція необхідна для оголошення кількох сигнатур функцій з однаковими іменами.
2. Створіть функцію **getTitles()**, яка повинна приймати 1 або 2 аргументи:
     - •	якщо функція приймає 1 аргумент, то він повинен бути або string (author), або boolean (available)
     - •	якщо функція приймає 2 аргументи, то вони повинні бути number (id) та boolean (available).
     + Функція повинна повертати масив книг за автором, чи за доступністю, чи за id та доступністю.
     + Для реалізації функції створіть три сигнатури з різними типами параметрів та реалізацію з рест параметром типу ``any[]`` або ``unknown[]`` або ``[string | boolean] | [number, boolean]``.
     + Функція повинна аналізувати кількість і типи параметрів за допомогою оператора ``typeof``
     + і формувати результуючий масив з масиву, отриманого за допомогою функції **getAllBooks()**, аналізуючи властивості: ``book.author, book.available, book.id``.
3. Оголосіть змінну **checkedOutBooks** та викличте функцію **getTitles(false)**.
     + Виведіть результат у консоль.

### Завдання 03.04. Функції-ствердження

1. Створіть функцію-ствердження **assertStringValue()**, яка повинна приймати один параметр типу any.
     - Функція повинна перевіряти, чи є тип переданого аргументу рядком. Якщо ні, то генерувати виняток ``"value should have been a string"``.
2. Створіть функцію **bookTitleTransform()**, яка повинна приймати один параметр ``title`` – назву книжки (тип параметру any).
     - За допомогою функції **assertStringValue()** повинна перевіряти, чи назва книжки дійсно є рядком,
     - і якщо так, то повинна повертати перевертень цього рядка, використовуючи спред оператор і методи масиву ``reverse()`` і ``join()``.
3. Викличте функцію **bookTitleTransform()** двічі і передайте їй рядкове та числове значення.

## Interfaces

### Завдання 04.01. Об’явлення інтерфейсу 

1. Об’явіть **інтерфейс Book**, який включає такі поля:
     - •	id - число
     - •	title - рядок
     - •	author - рядок
     - •	available - логічний
     - •	category – категорія
2. Внесіть зміни в функцію **getAllBooks()**, вкажіть тип для змінної ``books`` і тип для значення, що повертається, використовуючи інтерфейс Book. 
     - Додайте модифікатор ``readonly``. 
     - Видаліть тимчасово id у книжки. Ви побачите, що з'явиться помилка.
3. Внесіть зміни в функцію **getBookByID()**, вкажіть тип ``Book['id']`` для параметра ``id``, а також вкажіть тип для значення, що повертається, використовуючи інтерфейс Book. 
     - Можливо, доведеться додати об'єднання з типом ``undefined``, оскільки метод ``find``, якщо не знайде елемент, поверне undefined.
4. Створіть функцію **printBook()**, яка повинна приймати один параметр - книгу та виводити у консоль фразу ``book.title + by + book.author``. 
     - Використайте інтерфейс Book для типу параметра.
5. Об’явіть змінну **myBook** і присвойте їй наступний об'єкт
    + ```javascript
        {
            id: 5,
            title: 'Colors, Backgrounds, and Gradients',
            author: 'Eric A. Meyer',
            available: true,
            category: Category.CSS,
            year: 2015,
            copies: 3
        }
      ```
6. Викличте функцію **printBook()** та передайте їй ``myBook``. 
     - Жодних помилок при цьому не повинно з'являтися.
7. Додайте до інтерфейсу **Book** властивість ``pages: number``. 
     - Ви отримаєте помилку у функції **getAllBooks()**. 
     - Щоб помилка не виникала, зробіть властивість необов'язковою.
8. Вкажіть явно для змінної myBook тип Book. Ви знову отримаєте помилку. 
     - Видаліть властивості year, copies. 
     - Додайте властивість pages: 200.
9. Додайте в інтерфейс **Book** необов'язкову властивість ``markDamaged``, яка є методом.
     - Метод повинен приймати рядковий параметр ``reason`` і нічого не повертати.
     - Додайте цей метод до **myBook**. Метод повинен виводити рядок `Damaged: ${reason}`.
     - Викличте цей метод та передайте рядок ``'missing back cover'``.

### Завдання 04.02. Об’явлення інтерфейсу для функціонального типу

1. Об’явіть **інтерфейс DamageLogger**, який описуватиме тип функції, яка повинна приймати один рядковий параметр і нічого не повертати.
2. Внесіть зміни до **інтерфейсу Book**: використайте інтерфейс DamageLogger для поля markDamaged.
3. Об’явіть **змінну logDamage**, використовуючи інтерфейс **DamageLogger**. 
     - Створіть функцію, яка задовольняє цьому інтерфейсу, і присвойте її  змінній logDamage. 
     - Викличте функцію.

### Завдання 04.03. Розширення інтерфейсів

1. Об’явіть **інтерфейс Person**, який містить дві рядкові властивості – ``name`` і ``email``.
2. Об’явіть **інтерфейс Author** на основі інтерфейсу **Person**, який розширює вказаний інтерфейс числовою властивістю ``numBooksPublished``.
3. Об’явіть **інтерфейс Librarian** на основі інтерфейсу **Person**, який розширює цей інтерфейс двома властивостями:
     - •	Рядкова властивість department
     - •	Функція assistCustomer, яка повинна приймати два рядкові параметри custName і bookTitle і нічого не повертати.
4. Об’явіть **змінну favoriteAuthor**, використовуючи інтерфейс **Author**, задайте значення у вигляді літерала об'єкта.
5. Об’явіть **змінну favoriteLibrarian**, використовуючи інтерфейс **Librarian**, задайте значення у вигляді літерала об'єкта.

### Завдання 04.04. Необов’язковий ланцюжок

1. Об’явіть **змінну offer** наступного виду:
    + ```javascript
        const offer: any = {
           book: {
              title: 'Essential TypeScript',
           },
        };
      ```
2. Виведіть у консоль значення таких виразів, використовуючи оператор (?.)
     - •	offer.magazine
     - •	offer.magazine.getTitle()
     - •	offer.book.getTitle()
     - •	offer.book.authors[0]
     - •	offer.book.authors[0].name

### Завдання 04.05. keyof оператор

1. Об’явіть **тип BookProperties**, який має бути об’єднанням рядкових літеральних типів властивостей інтерфейсу **Book**, використовуючи ``keyof`` оператор.
2. Створіть **функцію getProperty()**, яка повинна приймати два параметри:
     - •	книжку
     - •	назву властивості з інтерфейсу Book
     - і повертати значення цієї властивості з переданого об'єкта, якщо це не функція, а для функції повертати її ім'я. 
     - Використайте тип ``any`` для значення, що повертається.
3. Викличте функцію ``getProperty()`` тричі зі значенням другого аргумента: title, markDamaged, isbn.

## Classes

### Завдання 05.01. Створення та використання класів



### Завдання 05.02. Розширення класів



### Завдання 05.03. Абстрактні класи



### Завдання 05.04. Реалізація інтерфейсів класами



### Завдання 05.05. Перетин та об’єднання типів




## Modules and Namespaces

### Завдання 06.01. Використання простору імен



### Завдання 06.02. Експорт та імпорт



### Завдання 06.03. Експорт за замовчуванням



### Завдання 06.04. Реекспорт



### Завдання 06.05. Вираз динамічного імпорту



### Завдання 06.06. Імпорт та експорт типів




## Generics

### Завдання 07.01. Загальні функції



### Завдання 07.02. Загальні інтерфейси і класи



### Завдання 07.03. Загальні обмеження



### Завдання 07.04. Утиліти



### Завдання 07.05. Відображені типи, умовні типи




## Decorators

### Завдання 08.01. Декоратор класу



### Завдання 08.02. Декоратор класу



### Завдання 08.03. Декоратор методу



### Завдання 08.04. Декоратор методу



### Завдання 08.05. Декоратор поля



### Завдання 08.06. Декоратор автоаксесора



### Завдання 08.07. Декоратор аксесорів




## Asynchronous Patterns

### Завдання 09.01. Функція зворотнього виклику



### Завдання 09.02. Проміси



### Завдання 09.03. Асинхронні функції













